defmodule EVM.OperationRefactored do
  @moduledoc """
  Refactored Operation module using compile-time metadata generation.
  This eliminates the need for separate metadata files.
  """

  alias EVM.Operation
  
  # Import the metadata registry
  import EVM.Operation.MetadataRegistry
  
  # List of operation modules - currently empty as operations are being refactored
  # This will be populated as refactored operation modules are completed
  # @operation_modules []
  
  # Temporarily define empty operations list until modules are created
  def all_operations, do: []
  
  # These will be properly generated once operation modules exist
  def get_metadata(_opcode), do: nil
  def get_operation(_opcode), do: nil
  def get_opcode(_operation), do: nil
  def all_opcodes, do: []
  
  # Collect metadata at compile time (will be empty for now)
  # collect_metadata(@operation_modules)
  
  # Generate dispatch functions
  # generate_dispatchers()
  
  # Additional helper functions
  @push1 0x60
  @push32 0x7f
  @push_operations @push1..@push32
  @jump_operations [:jump, :jumpi]
  @stop 0x00
  
  def jump_operations, do: @jump_operations
  def push_operations, do: @push_operations
  
  @doc """
  Returns the current operation at a given program counter address.
  """
  @spec get_operation_at(binary(), non_neg_integer()) :: byte()
  def get_operation_at(machine_code, program_counter)
      when is_binary(machine_code) and is_integer(program_counter) do
    case machine_code do
      <<_::binary-size(program_counter), opcode::8, _::binary>> -> opcode
      _ -> @stop
    end
  end
  
  @doc """
  Executes an operation based on its opcode.
  """
  @spec execute(byte(), Operation.stack_args(), Operation.vm_map()) :: Operation.op_result()
  def execute(opcode, stack_args, vm_map) do
    case get_metadata(opcode) do
      nil ->
        {:error, :invalid_opcode}
      
      %{sym: operation_sym} = metadata ->
        execute_operation(operation_sym, stack_args, vm_map, metadata)
    end
  end
  
  # Private function to dispatch to the actual operation implementation
  defp execute_operation(:add, args, vm_map, _metadata) do
    EVM.Operation.ArithmeticRefactored.Add.add(args, vm_map)
  end
  
  defp execute_operation(:mul, args, vm_map, _metadata) do
    EVM.Operation.ArithmeticRefactored.Mul.mul(args, vm_map)
  end
  
  defp execute_operation(:sub, args, vm_map, _metadata) do
    EVM.Operation.ArithmeticRefactored.Sub.sub(args, vm_map)
  end
  
  defp execute_operation(:div, args, vm_map, _metadata) do
    EVM.Operation.ArithmeticRefactored.Div.div(args, vm_map)
  end
  
  defp execute_operation(:mod, args, vm_map, _metadata) do
    EVM.Operation.ArithmeticRefactored.Mod.mod(args, vm_map)
  end
  
  defp execute_operation(:exp, args, vm_map, _metadata) do
    EVM.Operation.ArithmeticRefactored.Exp.exp(args, vm_map)
  end
  
  defp execute_operation(:sha3, args, vm_map, _metadata) do
    EVM.Operation.Sha3Refactored.sha3(args, vm_map)
  end
  
  defp execute_operation(_operation, _args, _vm_map, _metadata) do
    {:error, :not_implemented}
  end
  
  @doc """
  Validates if an operation has the correct number of stack arguments.
  """
  @spec validate_stack_args(byte(), list()) :: :ok | {:error, :insufficient_stack}
  def validate_stack_args(opcode, stack_args) do
    case get_metadata(opcode) do
      nil ->
        {:error, :invalid_opcode}
      
      %{input_count: required} ->
        if length(stack_args) >= required do
          :ok
        else
          {:error, :insufficient_stack}
        end
    end
  end
  
  @doc """
  Calculates gas cost for an operation.
  """
  @spec calculate_gas_cost(byte(), Operation.stack_args()) :: non_neg_integer()
  def calculate_gas_cost(opcode, stack_args) do
    case get_metadata(opcode) do
      nil ->
        0
      
      %{gas_cost: nil} ->
        3  # Default gas cost
      
      %{gas_cost: :dynamic, sym: :exp} ->
        # EXP has dynamic gas cost based on exponent size
        case stack_args do
          [_base, exponent] ->
            10 + 50 * byte_size(:binary.encode_unsigned(exponent))
          _ ->
            10
        end
      
      %{gas_cost: cost} when is_integer(cost) ->
        cost
    end
  end
end