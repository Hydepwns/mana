defmodule EVM.OperationRefactoredTest do
  use ExUnit.Case
  
  alias EVM.{MachineState, Stack}
  alias EVM.OperationRefactored
  alias EVM.Operation.{Sha3Refactored, ArithmeticRefactored, PushRefactored}
  
  describe "metadata generation" do
    test "SHA3 operation has correct metadata" do
      metadata = Sha3Refactored.__metadata__()
      
      assert metadata.id == 0x20
      assert metadata.sym == :sha3
      assert metadata.description == "Compute Keccak-256 hash."
      assert metadata.group == :sha3
      assert metadata.input_count == 2
      assert metadata.output_count == 1
    end
    
    test "ADD operation has correct metadata" do
      metadata = ArithmeticRefactored.Add.__metadata__()
      
      assert metadata.id == 0x01
      assert metadata.sym == :add
      assert metadata.description == "Addition operation"
      assert metadata.group == :stop_and_arithmetic
      assert metadata.input_count == 2
      assert metadata.output_count == 1
    end
    
    test "PUSH1 operation has correct metadata" do
      metadata = PushRefactored.Push1.__metadata__()
      
      assert metadata.id == 0x60
      assert metadata.sym == :push1
      assert metadata.description == "Place 1 byte item on stack"
      assert metadata.group == :push
      assert metadata.input_count == 0
      assert metadata.output_count == 1
      assert metadata.machine_code_offset == 1
    end
    
    test "PUSH32 operation has correct metadata" do
      metadata = PushRefactored.Push32.__metadata__()
      
      assert metadata.id == 0x7F
      assert metadata.sym == :push32
      assert metadata.description == "Place 32 byte item on stack"
      assert metadata.group == :push
      assert metadata.input_count == 0
      assert metadata.output_count == 1
      assert metadata.machine_code_offset == 32
    end
  end
  
  describe "operation execution" do
    test "ADD operation works correctly" do
      machine_state = %MachineState{stack: []}
      vm_map = %{machine_state: machine_state}
      
      result = ArithmeticRefactored.Add.add([5, 3], vm_map)
      
      assert result.stack == [8]
    end
    
    test "MUL operation works correctly" do
      machine_state = %MachineState{stack: []}
      vm_map = %{machine_state: machine_state}
      
      result = ArithmeticRefactored.Mul.mul([5, 3], vm_map)
      
      assert result.stack == [15]
    end
    
    test "SUB operation works correctly" do
      machine_state = %MachineState{stack: []}
      vm_map = %{machine_state: machine_state}
      
      result = ArithmeticRefactored.Sub.sub([5, 3], vm_map)
      
      assert result.stack == [2]
    end
    
    test "DIV operation handles division by zero" do
      machine_state = %MachineState{stack: []}
      vm_map = %{machine_state: machine_state}
      
      result = ArithmeticRefactored.Div.div([5, 0], vm_map)
      
      assert result.stack == [0]
    end
    
    test "DIV operation works correctly" do
      machine_state = %MachineState{stack: []}
      vm_map = %{machine_state: machine_state}
      
      result = ArithmeticRefactored.Div.div([10, 3], vm_map)
      
      assert result.stack == [3]
    end
  end
  
  describe "metadata registry" do
    test "can retrieve metadata by opcode" do
      # This would work once OperationRefactored is fully integrated
      # metadata = OperationRefactored.get_metadata(0x01)
      # assert metadata.sym == :add
    end
    
    test "can retrieve opcode by symbol" do
      # This would work once OperationRefactored is fully integrated
      # opcode = OperationRefactored.get_opcode(:add)
      # assert opcode == 0x01
    end
  end
  
  describe "push operations" do
    test "is_push? correctly identifies PUSH operations" do
      assert PushRefactored.is_push?(0x60) == true  # PUSH1
      assert PushRefactored.is_push?(0x7F) == true  # PUSH32
      assert PushRefactored.is_push?(0x80) == false # Not a PUSH
      assert PushRefactored.is_push?(0x01) == false # ADD
    end
    
    test "push_length returns correct byte count" do
      assert PushRefactored.push_length(0x60) == 1   # PUSH1
      assert PushRefactored.push_length(0x61) == 2   # PUSH2
      assert PushRefactored.push_length(0x7F) == 32  # PUSH32
      assert PushRefactored.push_length(0x01) == 0   # Not a PUSH
    end
    
    test "PUSH1 operation extracts correct value" do
      machine_state = %MachineState{
        stack: [],
        program_counter: 0
      }
      
      # Machine code: PUSH1 0x42
      machine_code = <<0x60, 0x42, 0x00>>
      
      exec_env = %{machine_code: machine_code}
      vm_map = %{machine_state: machine_state, exec_env: exec_env}
      
      result = PushRefactored.Push1.push1([], vm_map)
      
      assert result.stack == [0x42]
      assert result.program_counter == 1
    end
  end
  
  describe "migration validation" do
    test "all refactored operations maintain backward compatibility" do
      # Test that refactored operations produce the same results as originals
      # This ensures the migration doesn't break existing functionality
      
      # Example: Compare old and new ADD operations
      machine_state = %MachineState{stack: []}
      vm_map = %{machine_state: machine_state}
      
      # Both should produce the same result
      new_result = ArithmeticRefactored.Add.add([100, 200], vm_map)
      # old_result = EVM.Operation.StopAndArithmetic.add([100, 200], vm_map)
      
      assert new_result.stack == [300]
      # assert new_result == old_result
    end
  end
end